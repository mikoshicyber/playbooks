---
- name: Поиск, загрузка и установка файлов на Windows (с поддержкой mode=arc/files/pkg)
  hosts: all
  gather_facts: true

  pre_tasks:
    - name: Создать папку для фактов
      ansible.windows.win_file:
        path: C:\ProgramData\Ansible\facts.d
        state: directory
      tags: [always]

    - name: Установить скрипт факта
      ansible.windows.win_copy:
        changed_then: false
        dest: C:\ProgramData\Ansible\facts.d\installed_software.ps1
        content: |
          $keys = @(
            'HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall',
            'HKLM:\SOFTWARE\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall',
            'HKCU:\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall'
          )
          $apps = @()
          foreach ($key in $keys) {
            if (Test-Path $key) {
              Get-ChildItem $key | ForEach-Object {
                $meta = Get-ItemProperty $_.PSPath -ErrorAction SilentlyContinue
                if ($meta -and $meta.DisplayName -and -not $meta.SystemComponent) {
                  $prodid = if ($_.PSChildName -match '^\{[0-9A-Fa-f\-]+\}$') { $_.PSChildName } elseif ($meta.PSObject.Properties.Match('ProductID').Count -gt 0) { $meta.ProductID } else { $null }
                  $silent = if ($meta.QuietUninstallString) { $meta.QuietUninstallString } else { $meta.UninstallString }
                  $apps += [PSCustomObject]@{
                    name = $meta.DisplayName
                    version = if ($meta.PSObject.Properties.Match('DisplayVersion').Count -gt 0) { $meta.DisplayVersion } else { $null }
                    uninstall_string = $silent
                    product_id = $prodid
                    registry_key = $_.PSPath
                  }
                }
              }
            }
          }
          $apps
      tags: [always]

    - name: Настроить Defender
      ansible.builtin.include_tasks:
        file: defender.yaml
      tags: [never, defender]

  vars:
    local_dir: "/source"
    local_arc_tmp: "/tmp/ansible_arc"

  tasks:
    - name: Создать папку назначения на Windows
      ansible.windows.win_file:
        path: "{{ dest }}"
        state: directory
      tags: [always]

    - name: Собрать факты, включая кастомные
      ansible.windows.setup:
        fact_path: C:\ProgramData\Ansible\facts.d
      tags: [always]

    - name: Найти доступные локальные файлы на контроллере
      delegate_to: localhost
      run_once: true
      ansible.builtin.find:
        paths: "{{ local_dir }}"
        recurse: true
        file_type: file
        use_regex: true
        patterns: "(?i).*$"
      register: local_files
      tags: [always]

    - name: Сохранить список путей как факт на localhost
      delegate_to: localhost
      delegate_facts: true
      ansible.builtin.set_fact:
        local_paths: "{{ (local_files.files | default([])) | map(attribute='path') | list }}"
      tags: [always]

    - name: DEBUG local_paths
      ansible.builtin.debug:
        msg: "{{ {'local_paths': hostvars['localhost'].local_paths | default([])} }}"
      delegate_to: localhost
      run_once: true
      tags: [never, debug]

    - name: Сформировать эффективный список паттернов
      ansible.builtin.set_fact:
        patterns_effective: >-
          {{
            lookup('community.general.merge_variables','patterns__',wantlist=True,pattern_type='prefix',list_merge='append',recursive=True) | flatten
            + (patterns | default([]))
          }}
      tags: [always]

    - name: DEBUG patterns_effective
      ansible.builtin.debug:
        msg: "{{ {'patterns_effective': patterns_effective | default([])} }}"
      tags: [never, debug]

    - name: Построить пары паттерн×путь
      ansible.builtin.set_fact:
        pat_file_pairs: "{{ (patterns_effective | default([])) | product((hostvars['localhost'].local_paths | default([]))) | list }}"
      tags: [always]

    - name: DEBUG pat_file_pairs_count
      ansible.builtin.debug:
        msg: "{{ {'pat_file_pairs_count': (pat_file_pairs | length)} }}"
      tags: [never, debug]

    - name: Сформировать список кандидатов с версиями
      ansible.builtin.set_fact:
        exploded: "{{ (exploded|default([])) + [ {'pattern': item.0, 'file': item.1, 'base': (item.1 | basename), 'version': ((item.1 | basename) | regex_search('\\d+(?:\\.\\d+)+') | default('0', true)) } ] }}"
      loop: "{{ pat_file_pairs | default([]) }}"
      loop_control:
        label: "{{ item.1 | basename }}"
      when: item.1 | regex_search('(?i).*' ~ item.0.regex ~ '.*')
      tags: [always]

    - name: DEBUG exploded_progress
      ansible.builtin.debug:
        msg: "{{ {'exploded_len': (exploded | default([]) | length)} }}"
      tags: [never, debug]

    - name: Выбрать максимум по версии для каждого паттерна
      ansible.builtin.set_fact:
        best_map: "{{ (best_map|default({})) | combine({ (item.pattern.regex|string): item }, recursive=True) }}"
      loop: "{{ exploded | default([]) }}"
      loop_control:
        label: "{{ item['base'] }} -> {{ item['version'] }}"
      when: >
        ((best_map|default({})).get(item.pattern.regex|string, none) is none) or
        ((item.version|string) is version(((best_map|default({})).get(item.pattern.regex|string, {}).get('version','0')|string), '>'))
      tags: [always]

    - name: DEBUG best_map_keys
      ansible.builtin.debug:
        msg: "{{ {'best_map_keys': (best_map | default({}) | dict2items | map(attribute='key') | list)} }}"
      tags: [never, debug]

    - name: Итоговый список установок
      ansible.builtin.set_fact:
        install_items: "{{ (best_map|default({})) | dict2items | map(attribute='value') | list }}"
      tags: [always]

    - name: DEBUG install_items
      ansible.builtin.debug:
        msg: "{{ {'install_items': install_items | map(attribute='base') | list} }}"
      tags: [never, debug]

    - name: Найти маркеры _installed
      ansible.windows.win_find:
        paths: "{{ dest }}"
        patterns: ["*_installed"]
        recurse: false
      register: installed_found
      tags: [always]

    - name: Сформировать installed_targets
      ansible.builtin.set_fact:
        installed_targets: "{{ (installed_found.files | default([])) | map(attribute='path') | map('regex_replace','_installed$','') | list }}"
      tags: [always]

    - name: DEBUG installed_targets
      ansible.builtin.debug:
        msg: "{{ {'installed_targets': installed_targets | default([])} }}"
      tags: [never, debug]

    - name: Разобрать маркеры на продукт и версию
      ansible.builtin.set_fact:
        parsed_markers: >-
          {{
            (parsed_markers | default([])) + [
              {
                'name': (item.filename | default(item.path | basename)),
                'path': item.path,
                'key': (
                  (item.filename | default(item.path | basename))
                  | regex_replace('(?i)_installed$','')
                  | regex_replace('\\.[^.\\s]+$','')
                  | regex_replace('(?i)\\b(setup|installer|windows?|win|x86(?:-?64)?|x64|amd64|helppack(?:_ru)?|ru)\\b','')
                  | regex_replace('[\\s_\\-]+',' ')
                  | trim
                  | lower
                ),
                'version': (
                  ((item.filename | default(item.path | basename))
                    | regex_replace('(?i)_installed$','')
                    | regex_search('\\d+(?:[.,]\\d+)+|\\b\\d{8}\\b')
                    | default('0', true)
                    | regex_replace(',', '.')
                  )
                )
              }
            ]
          }}
      loop: "{{ installed_found.files | default([]) }}"
      loop_control:
        label: "{{ item.filename }}"
      tags: [always]

    - name: Выбрать самую новую версию по каждому продукту
      ansible.builtin.set_fact:
        best_map: "{{ (best_map|default({})) | combine({ item.key: item }, recursive=True) }}"
      loop: "{{ parsed_markers | default([]) }}"
      when: >
        (best_map is not defined)
        or (best_map.get(item.key) is not defined)
        or (
             (item.version is match('^\\d{8}$') and (item.version | int) > ((best_map.get(item.key).version | default('0')) | int))
             or
             (item.version is not match('^\\d{8}$') and ((item.version | string) is version((best_map.get(item.key).version | default('0') | string), '>')))
          )
      tags: [always]

    - name: Инициализировать planned_items
      ansible.builtin.set_fact:
        planned_items: []
      tags: [always]

    - name: Отобрать элементы для работы
      ansible.builtin.set_fact:
        planned_items: "{{ (planned_items | default([])) + [ item ] }}"
      loop: "{{ install_items | default([]) }}"
      when:
        - item.pattern.state | default('present') == 'absent'
          or item.pattern.force | default(false)
          or ((dest ~ '\\' ~ item.base) not in installed_targets)
      tags: [always]

    - name: DEBUG planned_items_after_filter
      ansible.builtin.debug:
        msg: "{{ {'planned_items': planned_items | map(attribute='base') | list} }}"
      tags: [never, debug]

    - name: Инициализировать _files_success
      ansible.builtin.set_fact:
        _files_success: []
      tags: [always]

    - name: Выполнить pre-команды
      ansible.windows.win_command: >-
        {{ (item.pattern.pre is string) | ternary(item.pattern.pre, (item.pattern.pre | join(' && '))) }}
      loop: "{{ planned_items | selectattr('pattern.pre','defined') | list }}"
      loop_control:
        label: "{{ item.pattern.pre }}"
      when: item.pattern.force | default(false)
      ignore_errors: true
      failed_when: false
      tags: [always]

    - name: Подготовить planned_items с путями к пакетам
      ansible.builtin.set_fact:
        planned_items_prepared: []
      tags: [always]

    - name: Построить planned_items_prepared
      ansible.builtin.set_fact:
        planned_items_prepared: >-
          {{ (planned_items_prepared | default([])) + [
               item | combine({
                 'pkg_path': ((remote_source is defined and (remote_source|length > 0))
                               | ternary(remote_source ~ '\\' ~ item.base,
                                         dest ~ '\\' ~ item.base))
               })
             ] }}
      loop: "{{ planned_items | default([]) }}"
      when: remote_source is defined and (remote_source|length > 0)
      loop_control:
        label: "{{ item.base }}"
      tags: [always]

    - name: Построить planned_items_prepared
      ansible.builtin.set_fact:
        planned_items_prepared: >-
          {{ (planned_items_prepared | default([])) + [
               item | combine({
                 'pkg_path': dest ~ '\\' ~ item.base
               })
             ] }}
      loop: "{{ planned_items | default([]) }}"
      loop_control:
        label: "{{ item.base }}"
      when: not (remote_source is defined and (remote_source|length > 0))
      tags: [always]

    - name: Сформировать списки по режимам
      ansible.builtin.set_fact:
        planned_items_arc: "{{ planned_items_prepared | selectattr('pattern.mode','defined') | selectattr('pattern.mode','equalto','arc') | list }}"
        planned_items_pkg: "{{ (planned_items_prepared | selectattr('pattern.mode','defined') | selectattr('pattern.mode','in',['exe','msi']) | list) + (planned_items_prepared | rejectattr('pattern.mode','defined') | list) }}"
        planned_items_files: "{{ planned_items_prepared | selectattr('pattern.mode','defined') | selectattr('pattern.mode','equalto','files') | list }}"
      tags: [always]

    - name: DEBUG planned_items_modes
      ansible.builtin.debug:
        msg:
          arc: "{{ planned_items_arc | map(attribute='base') | list }}"
          pkg: "{{ planned_items_pkg | map(attribute='base') | list }}"
          files: "{{ planned_items_files | map(attribute='base') | list }}"
      tags: [never, debug]

    - name: Предварительно удалить маркер для state=absent
      ansible.windows.win_file:
        path: "{{ dest }}\\{{ item.base }}_installed"
        state: absent
      loop: "{{ planned_items | selectattr('pattern.state','defined') | selectattr('pattern.state','equalto','absent') | list }}"
      loop_control:
        label: "{{ item.base }}"
      tags: [always]

    - name: Подключить обработку режима arc
      ansible.builtin.include_tasks:
        file: task_arc.yaml
      when: planned_items_arc | length > 0
      tags: [always]

    - name: Копировать exe/msi на Windows (если источник локальный)
      ansible.windows.win_copy:
        src: "{{ item.file }}"
        dest: "{{ dest }}\\{{ item.base }}"
      loop: "{{ planned_items_pkg }}"
      when:
        - remote_source is not defined or remote_source|length == 0
        - (item.pattern.mode | default('exe')) in ['exe','msi']
        - (item.pattern.state | default('present')) != 'absent'
      ignore_errors: true
      failed_when: false
      tags: [always]

    - name: Установить состояние пакетов через win_package
      ansible.windows.win_package:
        path: "{{ item.pkg_path }}"
        state: "{{ item.pattern.state | default('present') }}"
        product_id: "{{ item.pattern.product_id | default(omit) }}"
        arguments: "{{ (item.pattern.args | default([])) | join(' ') }}"
        creates_path: "{{ item.pattern.creates_path | default(omit) }}"
        expected_return_code: "{{ item.pattern.expected_return_code | default([0,3010]) }}"
        wait_for_children: "{{ item.pattern.wait_for_children | default(true) }}"
        chdir: "{{ dest }}"
      loop: "{{ planned_items_pkg }}"
      register: pkg_results
      when:
        - (item.pattern.state | default('present')) != 'absent'
        - (item.pattern.mode | default('exe')) in ['exe','msi']
      ignore_errors: true
      loop_control:
        label: "{{ item.base }}"
      tags: [always]

    - name: DEBUG pkg_results
      ansible.builtin.debug:
        msg: "{{ {'pkg_results': pkg_results } }}"
      delegate_to: localhost
      run_once: true
      tags: [never, debug]

    - name: Отобрать PKG с state=absent
      ansible.builtin.set_fact:
        absent_items: "{{ (planned_items_pkg | default([])) | selectattr('pattern.state','defined') | selectattr('pattern.state','equalto','absent') | list }}"
      tags: [always]

    - name: Построить пары пакет×установленная запись для удаления
      ansible.builtin.set_fact:
        uninstall_pairs: "{{ (uninstall_pairs | default([])) + [ {'pkg': item.0, 'app': item.1} ] }}"
      loop: "{{ (absent_items | default([])) | product(ansible_facts.installed_software | default([])) | list }}"
      loop_control:
        label: "{{ item.0.base }} <=?=> {{ item.1.name | default('') }}"
      when:
        - item.0.pattern.product_id is defined
        - (item.1.name | default('')) is regex(item.0.pattern.product_id, ignorecase=True)
      tags: [always]

    - name: Выполнить uninstall_string через PowerShell
      ansible.windows.win_shell: |
        $raw = @"
        {{ item.app.uninstall_string }}
        "@.Trim()

        $raw = [regex]::Replace(
          $raw,
          '(?i)(msiexec(?:\.exe)?)\s+/i\s*\{\s*(?<guid>[0-9A-Fa-f\-]+)\s*\}',
          '$1 /X "{${guid}}" /quiet /norestart'
        )

        $cmdLine = $null
        $m = [regex]::Match($raw, '^"(?<exe>[^"]+)"(?:\s+(?<args>.*))?$')

        if ($m.Success) {
          $exe  = $m.Groups['exe'].Value
          $args = $m.Groups['args'].Value
          if ([string]::IsNullOrWhiteSpace($args)) {
            $cmdLine = ('"{0}"' -f $exe)
            Write-Output "RUN: $cmdLine"
            $p = Start-Process -FilePath $exe -Wait -PassThru
          } else {
            $cmdLine = ('"{0}" {1}' -f $exe, $args)
            Write-Output "RUN: $cmdLine"
            $p = Start-Process -FilePath $exe -ArgumentList $args -Wait -PassThru
          }
        } else {
          $cmdLine = $raw
          Write-Output "RUN: $cmdLine"
          $p = Start-Process -FilePath 'cmd.exe' -ArgumentList @('/c', $raw) -Wait -PassThru
        }

        if ($p.ExitCode -is [int]) { exit $p.ExitCode } else { exit 0 }
      loop: "{{ uninstall_pairs | default([]) }}"
      loop_control:
        label: "{{ item.app.name }}"
      register: uninstall_results
      changed_when: true
      failed_when: uninstall_results.rc not in [0,3010]
      when:
        - uninstall_pairs is defined
      tags: [always]

    - name: Подключить обработку режима files
      ansible.builtin.include_tasks:
        file: task_files.yaml
      when: planned_items_files | length > 0
      tags: [always]

    - name: Удалить исходники после успешной установки (локальный источник)
      ansible.windows.win_file:
        path: "{{ dest }}\\{{ (item.item | default(item)).base }}"
        state: absent
      loop: "{{ pkg_results.results | default([]) }}"
      when:
        - remote_source is not defined or remote_source|length == 0
        - pkg_results is defined
        - (item.item.pattern.state | default('present')) != 'absent'
        - item.failed is not defined or not item.failed
        # - (item.rc is defined and (item.rc in [0,3010]))
      tags: [always]

    - name: Создать _installed для успешных и уже установленных (pkg)
      ansible.windows.win_file:
        path: "{{ dest }}\\{{ (item.item | default(item)).base }}_installed"
        state: touch
      loop: "{{ pkg_results.results | default([]) }}"
      when:
        - pkg_results is defined
        - (item.item.pattern.state | default('present')) != 'absent'
        - item is succeeded
      tags: [always]

    - name: Удалить маркер после успешного удаления (pkg via uninstall_string)
      ansible.windows.win_file:
        path: "{{ dest }}\\{{ item.pkg.base }}_installed"
        state: absent
      loop: "{{ uninstall_results.results | default([]) }}"
      when:
        - uninstall_results is defined
        - item.rc is defined
        - item.rc in [0,3010]
      loop_control:
        label: "{{ item.pkg.base }}"
      tags: [always]

    - name: Удалить исходник после успешного удаления (pkg)
      ansible.windows.win_file:
        path: "{{ dest }}\\{{ (item.item | default(item)).base }}"
        state: absent
      loop: "{{ pkg_results.results | default([]) }}"
      when:
        - pkg_results is defined
        - (item.item.pattern.state | default('present')) == 'absent'
        - item.failed is not defined or not item.failed
        - (item.rc is defined and (item.rc in [0,3010]))
      tags: [always]

    - name: Инициализировать success_items
      ansible.builtin.set_fact:
        success_items: []
      tags: [always]

    - name: Собрать успешные установки пакетов
      ansible.builtin.set_fact:
        pkg_success: >-
          {{
            (pkg_results.results | default([]))
            | selectattr('failed','defined') | rejectattr('failed')
            | selectattr('rc','defined') | selectattr('rc','in',[0,3010])
            | map(attribute='item') | map(attribute='base')
            | list | unique
          }}
      when: pkg_results is defined
      tags: [always]

    - name: Гарантировать наличие _arc_success / _files_success
      ansible.builtin.set_fact:
        _arc_success: "{{ _arc_success | default([]) }}"
        _files_success: "{{ _files_success | default([]) }}"
      tags: [always]

    - name: DEBUG финальные множества
      ansible.builtin.debug:
        msg:
          pkg_success: "{{ pkg_success | default([]) }}"
          _arc_success: "{{ _arc_success | default([]) }}"
          _files_success: "{{ _files_success | default([]) }}"
      tags: [never, debug]

    - name: Выполнить post-команды
      ansible.windows.win_command: >-
        {{ (item.pattern.post is string) | ternary(item.pattern.post, (item.pattern.post | join(' && '))) }}
      loop: "{{ planned_items | selectattr('pattern.post','defined') | list }}"
      loop_control:
        label: "{{ item.pattern.post }}"
      when: item.pattern.force | default(false) 
      ignore_errors: true
      failed_when: false
      tags: [always]

    - name: Сформировать финальный список успешных объектов по хосту
      ansible.builtin.set_fact:
        success_items: "{{ ((pkg_success | default([])) + (_arc_success | default([])) + (_files_success | default([]))) | unique }}"
      tags: [always]

    - ansible.builtin.include_tasks:
        file: clear_markers.yml
      tags: [always]

    - name: DEBUG success_items_final
      ansible.builtin.debug:
        msg: "{{ {'success_items': success_items | default([])} }}"
      tags: [never, debug]

    - name: Посчитать количество успешных установок
      delegate_to: localhost
      run_once: true
      ansible.builtin.set_fact:
        success_total: >-
          {{
            groups['all']
            | map('extract', hostvars, 'success_items')
            | map('default', [])
            | map('length')
            | sum
          }}
      tags: [always]

    - name: DEBUG success_total
      ansible.builtin.debug:
        msg: "{{ {'success_total': success_total | default(0)} }}"
      delegate_to: localhost
      run_once: true
      tags: [never, debug]

- name: "Отправим сообщение с хоста {{ ansible_play_hosts_all | first }}"
  hosts: "{{ ansible_play_hosts_all | first }}"
  gather_facts: false
  vars:
    success_total: >-
      {{
        groups['all']
        | map('extract', hostvars, 'success_items')
        | map('default', [])
        | map('length')
        | sum
      }}
  tasks:
    - name: Пропустить, если нечего отправлять
      meta: end_play
      when: success_total | int == 0
      tags: [always]

    - name: Отправить Telegram-уведомление
      ansible.builtin.include_tasks:
        file: telegram.yaml
      tags: [always]
